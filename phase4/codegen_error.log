CODE GENERATION
Input:  annotated_ast.txt - from Phase 3
Output: program.s (x86_64 Assembly)


Using input file: ../phase3/annotated_ast.txt

INPUT FILE: ../phase3/annotated_ast.txt

Annotated AST Preview:
──────────────────────────
 ANNOTATED_PROGRAM:
 Node_Type: PROGRAM
 Semantic_Type: PROGRAM_BLOCK
 Line: 1
 Statements: 3
 Analysis_Status: VALIDATED
 Statement_1:
 Node_Type: ASSIGNMENT (line 1)
 Line: 1
 Semantic_Type: BOOLEAN
 ... (truncated)

Total lines: 54
Semantic annotations: 2
Symbol references: 0


COMPILATION OPTIONS

Target Architecture: x86_64
Assembler: GNU as (gas)
Linker: GNU ld
Output Format: ELF64

Optimization Level: -O0 (none)
Debug Information: Included
Symbol Table: Generated


LOADING ANNOTATED AST FROM: ../phase3/annotated_ast.txt

Found PROGRAM node
Found ASSIGNMENT: unknown
Found EXPRESSION_STMT
AST loaded
Total nodes: 3
Assignments: 1
Expressions: 1


┌─ CODE GENERATION
│
│ Target: x86_64 Assembly
│ Output: program.s
│
│ Generating code for program with 2 statements
│ 
│ Statement 1:
│ 
│ Statement 2:
│   Generating expression statement
│     Generating binary operation: OR
│     Simulating B OR C operation
│ 
│ Generating program exit
│
│ Generated 4 assembly instructions
│ Symbol table contains 0 variables
│ Variables allocated: 0
│ Stack space required: 0 bytes
│
└─

┌─ WRITING ASSEMBLY FILE
│
│ ✓ Header and entry point written
│ ✓ 4 instructions written
│ ✓ System exit code written
│ ✓ Assembly file closed
│
└─

GENERATED ASSEMBLY: program.s

Assembly Code Preview:
──────────────────────────
 # Assembly code generated by Roadmap Compiler Phase 4
 # Target Architecture: x86_64
 # Source: Logical expressions (B = TRUE, C = FALSE, B OR C)
 #
 .section .text
 .global _start
 _start:
     # Program entry point
     # Generated code begins
     movq     $1, %rax    # Load B = TRUE
     movq     $0, %rbx    # Load C = FALSE
     orq      %rbx, %rax    # B OR C (result in RAX)
 ... (truncated)

Statistics:
Total lines: 22
Instructions: 0
Comments: 15
Labels: 1



BUILD INSTRUCTIONS

 To assemble and link the generated code:

 1. Assemble:  as -64 program.s -o program.o
 2. Link:      ld program.o -o program
 3. Run:       ./program

 Alternative (GCC):
 1. Compile:   gcc program.s -o program
 2. Run:       ./program



Assembly code generation complete!
