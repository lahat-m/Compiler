#ifndef _GNU_SOURCE
#define _GNU_SOURCE
#endif

#include "code_generator.h"

// Forward declarations for instruction writers
void write_x86_64_instruction(FILE* file, Instruction* inst, char operand_strs[][64]);
void write_arm64_instruction(FILE* file, Instruction* inst, char operand_strs[][64]);
void write_generic_instruction(FILE* file, Instruction* inst, char operand_strs[][64]);

// Write assembly file header
void write_assembly_header(FILE* file, TargetArch target) {
    fprintf(file, "# Assembly code generated by Roadmap Compiler Phase 4\n");
    fprintf(file, "# Target Architecture: %s\n", 
            target == TARGET_X86_64 ? "x86_64" : "ARM64");
    fprintf(file, "# Source: Logical expressions (B = TRUE, C = FALSE, B OR C)\n");
    fprintf(file, "#\n\n");
    
    if (target == TARGET_X86_64) {
        fprintf(file, ".section .text\n");
        fprintf(file, ".global _start\n\n");
        fprintf(file, "_start:\n");
        fprintf(file, "    # Program entry point\n");
    } else if (target == TARGET_ARM64) {
        fprintf(file, ".section .text\n");
        fprintf(file, ".global _start\n\n");
        fprintf(file, "_start:\n");
        fprintf(file, "    // Function entry point\n");
        fprintf(file, "    stp x29, x30, [sp, #-16]!\n");
        fprintf(file, "    mov x29, sp\n");
        fprintf(file, "    sub sp, sp, #32    // Allocate stack space\n\n");
    }
}

// Write assembly file footer
void write_assembly_footer(FILE* file, TargetArch target) {
    if (target == TARGET_X86_64) {
        fprintf(file, "\n    # System exit\n");
        fprintf(file, "    mov $60, %%rax    # sys_exit system call\n");
        fprintf(file, "    mov $0, %%rdi     # exit status (success)\n");
        fprintf(file, "    syscall           # invoke system call\n\n");
        fprintf(file, "# End of generated assembly\n");
    } else if (target == TARGET_ARM64) {
        fprintf(file, "\n    // Program exit\n");
        fprintf(file, "    mov x8, #93       // sys_exit\n");
        fprintf(file, "    mov x0, #0        // exit status\n");
        fprintf(file, "    svc #0\n\n");
        fprintf(file, "# End of generated assembly\n");
    }
}

// Write data section for variables
void write_data_section(FILE* file, CodeGenContext* ctx) {
    if (!ctx->symbol_map) return;
    
    fprintf(file, "\n# Data section for boolean variables\n");
    fprintf(file, ".section .data\n");
    
    struct SymbolMap* sym = ctx->symbol_map;
    while (sym) {
        if (ctx->target == TARGET_X86_64) {
            fprintf(file, "    %-8s: .quad 0    # Boolean variable %s\n", 
                    sym->name, sym->name);
        } else if (ctx->target == TARGET_ARM64) {
            fprintf(file, "    %-8s: .dword 0   # Boolean variable %s\n", 
                    sym->name, sym->name);
        }
        sym = sym->next;
    }
    fprintf(file, "\n");
}

// Write BSS section for uninitialized variables
void write_bss_section(FILE* file, CodeGenContext* ctx) {
    if (!ctx->symbol_map) return;
    
    fprintf(file, "# BSS section for uninitialized variables\n");
    fprintf(file, ".section .bss\n");
    
    struct SymbolMap* sym = ctx->symbol_map;
    while (sym) {
        if (ctx->target == TARGET_X86_64) {
            fprintf(file, "    .lcomm %s_storage, 8    # Storage for %s\n", 
                    sym->name, sym->name);
        } else if (ctx->target == TARGET_ARM64) {
            fprintf(file, "    .lcomm %s_storage, 4    # Storage for %s\n", 
                    sym->name, sym->name);
        }
        sym = sym->next;
    }
    fprintf(file, "\n");
}

// Format operand for assembly output
void format_operand(char* buffer, size_t size, Operand* op, TargetArch target) {
    switch (op->type) {
        case OPERAND_REGISTER:
            if (target == TARGET_X86_64) {
                snprintf(buffer, size, "%%%s", register_to_string(op->value.reg, target));
            } else if (target == TARGET_ARM64) {
                snprintf(buffer, size, "%s", register_to_string(op->value.reg, target));
            } else {
                snprintf(buffer, size, "%s", register_to_string(op->value.reg, target));
            }
            break;
            
        case OPERAND_IMMEDIATE:
            if (target == TARGET_X86_64) {
                snprintf(buffer, size, "$%d", op->value.immediate);
            } else if (target == TARGET_ARM64) {
                snprintf(buffer, size, "#%d", op->value.immediate);
            } else {
                snprintf(buffer, size, "#%d", op->value.immediate);
            }
            break;
            
        case OPERAND_MEMORY:
            if (target == TARGET_X86_64) {
                if (op->value.memory.offset == 0) {
                    snprintf(buffer, size, "(%%%s)", 
                            register_to_string(op->value.memory.base, target));
                } else if (op->value.memory.offset > 0) {
                    snprintf(buffer, size, "%d(%%%s)", 
                            op->value.memory.offset,
                            register_to_string(op->value.memory.base, target));
                } else {
                    snprintf(buffer, size, "%d(%%%s)", 
                            op->value.memory.offset,
                            register_to_string(op->value.memory.base, target));
                }
            } else if (target == TARGET_ARM64) {
                snprintf(buffer, size, "[%s, #%d]", 
                        register_to_string(op->value.memory.base, target),
                        op->value.memory.offset);
            }
            break;
            
        case OPERAND_LABEL:
            snprintf(buffer, size, "%s", op->value.label);
            break;
            
        default:
            snprintf(buffer, size, "UNKNOWN_OPERAND");
            break;
    }
}

// Write single instruction
void write_instruction(FILE* file, Instruction* inst, TargetArch target) {
    if (inst->type == INST_LABEL) {
        fprintf(file, "%s:\n", inst->operands[0].value.label);
        return;
    }
    
    char operand_strs[3][64];
    
    // Format operands
    for (int i = 0; i < inst->operand_count; i++) {
        format_operand(operand_strs[i], sizeof(operand_strs[i]), 
                      &inst->operands[i], target);
    }
    
    // Write instruction with proper syntax for target architecture
    if (target == TARGET_X86_64) {
        write_x86_64_instruction(file, inst, operand_strs);
    } else if (target == TARGET_ARM64) {
        write_arm64_instruction(file, inst, operand_strs);
    } else {
        write_generic_instruction(file, inst, operand_strs);
    }
}

// Write x86_64 specific instruction
void write_x86_64_instruction(FILE* file, Instruction* inst, char operand_strs[][64]) {
    const char* mnemonic = instruction_to_string(inst->type);
    
    // Handle special x86_64 instruction formatting
    switch (inst->type) {
        case INST_MOV:
            if (inst->operand_count == 2) {
                fprintf(file, "    movq     %s, %s", operand_strs[1], operand_strs[0]);
            }
            break;
            
        case INST_ADD:
            if (inst->operand_count == 2) {
                fprintf(file, "    addq     %s, %s", operand_strs[1], operand_strs[0]);
            }
            break;
            
        case INST_SUB:
            if (inst->operand_count == 2) {
                fprintf(file, "    subq     %s, %s", operand_strs[1], operand_strs[0]);
            }
            break;
            
        case INST_OR:
            if (inst->operand_count == 2) {
                fprintf(file, "    orq      %s, %s", operand_strs[1], operand_strs[0]);
            }
            break;
            
        case INST_AND:
            if (inst->operand_count == 2) {
                fprintf(file, "    andq     %s, %s", operand_strs[1], operand_strs[0]);
            }
            break;
            
        case INST_XOR:
            if (inst->operand_count == 2) {
                fprintf(file, "    xorq     %s, %s", operand_strs[1], operand_strs[0]);
            }
            break;
            
        case INST_CMP:
            if (inst->operand_count == 2) {
                fprintf(file, "    cmpq     %s, %s", operand_strs[1], operand_strs[0]);
            }
            break;
            
        case INST_PUSH:
            fprintf(file, "    pushq    %s", operand_strs[0]);
            break;
            
        case INST_POP:
            fprintf(file, "    popq     %s", operand_strs[0]);
            break;
            
        case INST_CALL:
            fprintf(file, "    call     %s", operand_strs[0]);
            break;
            
        case INST_RET:
            fprintf(file, "    ret");
            break;
            
        case INST_JMP:
            fprintf(file, "    jmp      %s", operand_strs[0]);
            break;
            
        case INST_JE:
            fprintf(file, "    je       %s", operand_strs[0]);
            break;
            
        case INST_JNE:
            fprintf(file, "    jne      %s", operand_strs[0]);
            break;
            
        default:
            fprintf(file, "    %-8s", mnemonic);
            for (int i = 0; i < inst->operand_count; i++) {
                fprintf(file, "%s%s", i == 0 ? " " : ", ", operand_strs[i]);
            }
            break;
    }
    
    // Add comment if present
    if (inst->comment) {
        fprintf(file, "    # %s", inst->comment);
    }
    
    fprintf(file, "\n");
}

// Write ARM64 specific instruction
void write_arm64_instruction(FILE* file, Instruction* inst, char operand_strs[][64]) {
    const char* mnemonic;
    
    // Map x86 instructions to ARM64 equivalents
    switch (inst->type) {
        case INST_MOV:
            mnemonic = "mov";
            break;
        case INST_ADD:
            mnemonic = "add";
            break;
        case INST_SUB:
            mnemonic = "sub";
            break;
        case INST_OR:
            mnemonic = "orr";
            break;
        case INST_AND:
            mnemonic = "and";
            break;
        case INST_XOR:
            mnemonic = "eor";
            break;
        case INST_CMP:
            mnemonic = "cmp";
            break;
        case INST_RET:
            fprintf(file, "    ret");
            if (inst->comment) {
                fprintf(file, "      // %s", inst->comment);
            }
            fprintf(file, "\n");
            return;
        default:
            mnemonic = instruction_to_string(inst->type);
            break;
    }
    
    fprintf(file, "    %-8s", mnemonic);
    for (int i = 0; i < inst->operand_count; i++) {
        fprintf(file, "%s%s", i == 0 ? " " : ", ", operand_strs[i]);
    }
    
    if (inst->comment) {
        fprintf(file, "    // %s", inst->comment);
    }
    
    fprintf(file, "\n");
}

// Write generic instruction (fallback)
void write_generic_instruction(FILE* file, Instruction* inst, char operand_strs[][64]) {
    fprintf(file, "    %-8s", instruction_to_string(inst->type));
    
    for (int i = 0; i < inst->operand_count; i++) {
        fprintf(file, "%s%s", i == 0 ? " " : ", ", operand_strs[i]);
    }
    
    // Add comment if present
    if (inst->comment) {
        fprintf(file, "    # %s", inst->comment);
    }
    
    fprintf(file, "\n");
}

// Main assembly generation function
int generate_assembly(CodeGenContext* ctx, ASTNode* ast, const char* output_file) {
    if (!ctx || !ast) return -1;
    
    printf("┌─ CODE GENERATION\n");
    printf("│\n");
    printf("│ Target: %s\n", ctx->target == TARGET_X86_64 ? "x86_64 Assembly" : 
           ctx->target == TARGET_ARM64 ? "ARM64 Assembly" : "Generic Assembly");
    printf("│ Output: %s\n", output_file);
    printf("│\n");
    
    // Generate intermediate representation
    generate_program(ctx, ast);
    
    printf("│\n");
    printf("│ Generated %d assembly instructions\n", ctx->instruction_count);
    printf("│ Symbol table contains %d variables\n", 
           ctx->symbol_map ? 1 : 0); // Count symbols
    
    // Count actual symbols
    int symbol_count = 0;
    struct SymbolMap* sym = ctx->symbol_map;
    while (sym) {
        symbol_count++;
        sym = sym->next;
    }
    printf("│ Variables allocated: %d\n", symbol_count);
    printf("│ Stack space required: %d bytes\n", ctx->stack_offset);
    printf("│\n");
    printf("└─\n\n");
    
    // Write assembly file
    FILE* file = fopen(output_file, "w");
    if (!file) {
        fprintf(stderr, "Error: Cannot create assembly file %s\n", output_file);
        return -1;
    }
    
    printf("┌─ WRITING ASSEMBLY FILE\n");
    printf("│\n");
    
    // Write header
    write_assembly_header(file, ctx->target);
    printf("│ ✓ Header and entry point written\n");
    
    // Write main code
    fprintf(file, "    # Generated code begins\n");
    Instruction* inst = ctx->instructions;
    int inst_count = 0;
    
    while (inst) {
        write_instruction(file, inst, ctx->target);
        inst = inst->next;
        inst_count++;
    }
    
    printf("│ ✓ %d instructions written\n", inst_count);
    
    // Write footer
    write_assembly_footer(file, ctx->target);
    printf("│ ✓ System exit code written\n");
    
    // Write data section if we have symbols
    if (ctx->symbol_map) {
        write_data_section(file, ctx);
        printf("│ ✓ Data section written (%d variables)\n", symbol_count);
    }
    
    // Write BSS section for debugging
    if (ctx->symbol_map) {
        fprintf(file, "\n# Debug information\n");
        fprintf(file, "# Variables used in this program:\n");
        sym = ctx->symbol_map;
        while (sym) {
            fprintf(file, "#   %s (offset: -%d from RBP)\n", 
                    sym->name, sym->stack_offset);
            sym = sym->next;
        }
    }
    
    fclose(file);
    
    printf("│ ✓ Assembly file closed\n");
    printf("│\n");
    printf("└─\n\n");
    
    return 0;
}